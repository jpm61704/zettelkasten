created: 20210104184642175
modified: 20210106200340183
title: TivvaExamplesIsFive
type: text/vnd.tiddlywiki

To test algebraic encodings for predicates as the intermediate view for [[Tivva]], let's begin with a silly-simple example. Consider the simple predicate `IsFive`:

$$
\frac{ }{ \textsf{IsFive } 5} {\tiny(\texttt{five-is-five})}
$$

Which, in agda would be defined using a type family:

```
data IsFive : ℕ → Set where
  five-is-five : IsFive 5
```

Next we want to consider how to encode this algebraically.

! Algebraic Encodings

!! First Try

A first try at encoding might be: 

```
isFive : ℕ → Set
isFive 5 = ⊤
isFive _ = ⊥
```

But this version has the unfortunate side-effect that it is not fully algebraic. We have related all the natural numbers to an algebraic type, but using a function. We want to go one step further and remove the use of functions entirely, so that we can do analysis without gross functions everywhere.

!! Second Try

We could also write an equivalent almost-algebraic predicate:

```
isFive : ℕ → Set
isFive = (_≡ 5)
```

This captures `isFive` as a function again, but it is only over a single clause. This is a bit better. One downside though: we had to introduce propositional equality($$\equiv)$$. This is likely a feature we will need in this representation though. 

!! Third Time's the Charm

Our final representation will have the benefit of being fully algebraic(with propositional equality). This is will be the encoding we want to move forward with for now:

```
isFive : Set
isFive = Σ[ n ∈ ℕ ] (n ≡ 5)
```

''To get this encoding'' we start with the inductive family we defined above,

```
data IsFive : ℕ → Set where
  five-is-five : IsFive 5
```

and create a $$\Sigma$$-type index for each of the indices in the family.

```
Σ[ n ∈ ℕ ] ???
```

Then, with our `five-is-five` constructor, we must have `n ≡ 5` to satisfy `IsFive n = IsFive 5`. This can also be looked at as the inference rule:

$$
\frac{n \equiv 5}{\textsf{IsFive } n}
$$

i.e. we only ever want our predicate to be applied to $$\Sigma$$-instantiated variables. The premises then become the dependent-term in the dependent-product: 

```
IsFive = Σ[ n ∈ ℕ ] (n ≡ 5)
```

! Tivva on `IsFive`

Let's continue on with the rest of the Tivva process. The transform will be the function `changeNat`.

```
changeNat : ℕ → ℕ → ℕ
changeNat n' _ = n'
```
We would like to show that `changeNat`, in some **//set of situations//**, is able to preserve proof of `IsFive`. This is shown by giving an instance of [[reprovable|Reprovable]]. 

The instance of `Reprovable` below should eventually be generated by an algorithm. This is the goal of Tivva.

```
ex : Reprovable IsFive changeNat
ex = record { subproofs =  λ { n' _ → n' ≡ 5 }
            ; reprove   =  λ { n' n-is-five refl → five-is-five } }
```

Now, how did I get this from the algebraic encoding `isFive`? What is
the analysis that needs to be done to get this?

 ```
Σ[ n ∈ ℕ ] (n ≡ 5)
```

`n` here, is the focus of the predicate. Which is also the dependent term in this
dependent product type. If we have one such product:

```
n , n≡5
```

And then apply a transform to n. We need to re-construct the product with the transform also applied to all dependent terms. Here,
this is:

```
(changeNat n' n) , ?{ changeNat n' n ≡ 5 }?
```

This can be simplified to:

```
n' , ?{ n' ≡ 5 }?
```

In this step, we need to be able to resolve `changeNat` into concrete values so
that we can continue the proof process. This resolution may end up being the
tricky part for more complicated transforms and predicates. This hole tells us
what we need to construct the full proof-term. This is the clause we need to
write the subproofs function.

The reprove part should follow simply from matching on any of the "required"
proof terms from subproofs.

This example doesn't deal with any "pushing down" of proof terms under changes.
This is the harder part. But it requires a fixed point to occur somewhere in our
definition. This is the next part to deal with I think.